load parse_msg.maude
load socket.maude

fmod STRING-LIST is
    protecting STRING .

    sort StringList .
    subsort String < StringList .
    op nil : -> StringList [ctor] .
    op __ : StringList StringList -> StringList [ctor assoc id: nil] .
endfm

mod OO-POPULATION is
    protecting NAT .
    protecting STRING-LIST .
    protecting PARSE-MSG .
    protecting SOCKET .

    *** Objects, messages, object names, and configurations:
    --- sorts Oid Object Msg Configuration .
    --- subsorts Object Msg < Configuration .
    --- op none : -> Configuration [ctor] .
    --- op __ : Configuration Configuration -> Configuration [ctor assoc comm id: none] .

    subsort String < Oid .

    *** Message for separating from spouse:
    op separate : Oid -> Msg [ctor] .

    sort Status .
    op single : -> Status [ctor] .
    ops engaged married separated : Oid -> Status [ctor] .
    
    ops Boynames Girlnames : StringList -> Msg .
    op relationshipStatus : Oid Status -> Msg .
    op age : Oid Nat -> Msg .
    op birthday : Oid -> Bool .

    ---op parent : Oid Oid -> Bool .
    ---ops male female : Oid -> Bool .
    *** these must be deduced by prolog program family.pl
    ---ops father mother brother sister uncle aunt grandfather grandmother : Oid Oid -> Bool .

    ---subsort Bool < Msg .
    ---op neg : Bool -> Bool .

    *** Socket stuff
    op Client : -> Cid .
    op aClient : -> Oid .


    *** Socket-related equations
    op createClientSocket : String Nat -> Msg .
    op plQuery : String String Nat -> Msg . *** Prolog Query, IP, PORT
    op plMsg : String -> Msg .
    
    *** need some way of saying if the terms brother(O, O') or (not brother(O, O')) does not exist,
    *** then the prolog server should be queried
    *** * use a function neg : Bool -> Bool (and subsort Bool < Msg) for not brother(O, O')
    *** * then use the contains function to check if neither of brother(O, O') nor neg(brother(O, O') exists, then query prolog

    vars X X' X'' X''' X'''' : String .
    vars FATHER MOTHER : Oid .
    vars N N' : Nat .
    vars S S' : Status .
    vars L L' L'' : StringList .
    vars C C' Conf : Configuration .
    vars O O' : Oid .

    sort State .
    ---subsort 
    op {_} : Configuration -> State [ctor] .
    op contains : Configuration State -> Bool .
    eq contains(C, {none}) = false . --- plQuery(c)
    eq contains(C, {C' Conf}) = if C == C' then true else contains(C, {Conf}) fi . 
    ---ceq contains(C, C' Conf) = true ---[print "C = " C]
        ---if C == C' [print "C = " C] .
    ---ceq contains(C, C' Conf) = contains(C, Conf) ---[print "C == " C]
        ---if C =/= C' [print "C == " C] .


    ---(
    op notSibling : String String Configuration -> Bool .
    eq notSibling(O, O', C) = if plContains(C, sibling(O, O'))
        then false
        else (if plContains(C, neg(sibling(O, O')))
            then true
            else plQuery("sibling(" + O + "," + O' + ")\n", "localhost", 3050) fi) fi .
    )

    rl [bday] :
        age(O, N)
        birthday(O)
      =>
        age(O, N + 1) .

    rl [not_bday] :
        age(O, N)
        neg(birthday(O))
      =>
        age(O, N + 5) .



    ---(
    crl [engagement] :
        relationshipStatus(O, single) age(O, N)
        relationshipStatus(O', single) age(O', N')
        C
        ---neg(sibling(O, O')) *** siblings can not be engaged (this term can be missing)
      =>
        relationshipStatus(O, engaged(O')) age(O, N)
        relationshipStatus(O', engaged(O)) age(O', N')
        C
        ---neg(sibling(O, O'))
      ---if N > 15 /\ N' > 15 /\ notSibling(O, O', C) .
      if notSibling(O, O', C) .
      )

    crl [engagement] :
        { relationshipStatus(O, single) ---age(O, N)
        relationshipStatus(O', single) ---age(O', N')
        Conf }
        ---neg(sibling(O, O')) *** siblings can not be engaged (this term can be missing)
      =>
        { relationshipStatus(O, engaged(O')) ---age(O, N)
        relationshipStatus(O', engaged(O)) ---age(O', N')
        Conf }
        ---neg(sibling(O, O'))
      ---if N > 15 /\ N' > 15 /\ notSibling(O, O', C) .
      if contains(neg(sibling(O, O')), {Conf}) or contains(neg(sibling(O', O)), {Conf}) .

    ---(
    var BABY : String .
    crl [girlBirth] :
        relationshipStatus(FATHER, married(MOTHER)) age(FATHER, N) male(FATHER)
        relationshipStatus(MOTHER, married(FATHER)) age(MOTHER, N') female(MOTHER)
        Girlnames(L BABY L')
      =>
        relationshipStatus(FATHER, married(MOTHER)) age(FATHER, N) male(FATHER)
        relationshipStatus(MOTHER, married(FATHER)) age(MOTHER, N') female(MOTHER)
        Girlnames(L L') *** Unique names
        relationshipStatus(BABY, single) age(BABY, 0) female(BABY)
        parent(FATHER, BABY)
        parent(MOTHER, BABY)
      if  N' < 60 .

    crl [boyBirth] :
        relationshipStatus(FATHER, married(MOTHER)) age(FATHER, N) male(FATHER)
        relationshipStatus(MOTHER, married(FATHER)) age(MOTHER, N') female(MOTHER)
        Boynames(L BABY L')
      =>
        relationshipStatus(FATHER, married(MOTHER)) age(FATHER, N) male(FATHER)
        relationshipStatus(MOTHER, married(FATHER)) age(MOTHER, N') female(MOTHER)
        Boynames(L L') *** Unique names
        relationshipStatus(BABY, single) age(BABY, 0) male(BABY)
        parent(FATHER, BABY)
        parent(MOTHER, BABY)
      if  N' < 60 .

    rl [separationInit] :
        relationshipStatus(O, married(O'))
      =>
        relationshipStatus(O, separated(O'))
        separate(O') .

    *** frewrite virker å være bugga da separate(X) meldingen ikke blir borte
    rl [acceptSeparation] :
        separate(X)
        relationshipStatus(X, married(X'))
      =>
        relationshipStatus(X, separated(X')) .

    rl [marriage] : 
        relationshipStatus(O, engaged(O'))
        relationshipStatus(O', engaged(O))
      =>
        relationshipStatus(O, married(O'))
        relationshipStatus(O', married(O)) .

    rl [divorce] :
        relationshipStatus(O, separated(O'))
        relationshipStatus(O', separated(O))
      =>
        relationshipStatus(O, single)
        relationshipStatus(O', single) .
  
    rl [birthday] :
        age(O, N)
      =>
        age(O, N + 1) .
    )


    vars CLIENT : Oid .
    var A : AttributeSet .
    vars IP MSG : String .
    vars PORT : Nat .

    
    rl [createSocket] :
        plQuery(MSG, IP, PORT)
	      < O : Client | A >
      =>
        plMsg(MSG)
	      < O : Client | A >
        createClientTcpSocket(socketManager, O, IP, PORT) .

    --- må ha disse i alle regler hvor kommunikasjon med serveren er nødvendig?
    rl [createdSocket] :
	      < O : Client | A >
        createdSocket(O, socketManager, CLIENT)
        plMsg(MSG)
      =>
        < O : Client | A >
        send(CLIENT, O, MSG) .

    rl [sent] :
	      < O : Client | A >
        sent(O, CLIENT)
      =>
        < O : Client | A >
        receive(CLIENT, O) .

    --- transform message received from prolog server to a term
    rl [receivedReply] :
	      < O : Client | A >
        received(O, CLIENT, MSG)
      => 
	      < O : Client | A > 
        msgToTerm(MSG) .

    crl [engagementQuery] :
        { relationshipStatus(X, single)
        relationshipStatus(X', single)
        Conf }
      =>
        { relationshipStatus(X, single)
        relationshipStatus(X', single)
        Conf
        plQuery("sibling(" + X + "," + X' + ")\n", "localhost", 3055) }
      if not (contains(sibling(X, X'), {Conf}))
          /\ not (contains(sibling(X', X), {Conf}))
          /\ not (contains(neg(sibling(X, X')), {Conf})) 
          /\ not (contains(neg(sibling(X', X)), {Conf})) 
          /\ not (contains(plQuery("sibling(" + X + "," + X' + ")\n", "localhost", 3055), {Conf}))
          /\ not (contains(plQuery("sibling(" + X' + "," + X + ")\n", "localhost", 3055), {Conf}))
          /\ not (contains(plMsg("sibling(" + X + "," + X' + ")\n"), {Conf}))
          /\ not (contains(plMsg("sibling(" + X' + "," + X + ")\n"), {Conf})) .

    ops greeks greekStatus : -> Configuration .
    eq greeks =
        Boynames("Zeus" "Hades")
        Girlnames("Hera")
        female("Gaia") age("Gaia", 999) relationshipStatus("Gaia", married("Uranus"))
        male("Uranus") age("Uranus", 900) relationshipStatus("Uranus", married("Gaia"))
        male("Kronos") age("Kronos", 800) relationshipStatus("Kronos", married("Rhea"))
        female("Rhea") age("Rhea", 21) relationshipStatus("Rhea", married("Kronos")) .

    eq greekStatus =
        relationshipStatus("Gaia", married("Uranus")) age("Gaia", 999)
        relationshipStatus("Uranus", married("Gaia")) age("Uranus", 900)
        relationshipStatus("Kronos", married("Rhea")) age("Kronos", 800)
        relationshipStatus("Rhea", married("Kronos")) age("Rhea", 21) .

    op testMarriage : -> Configuration .
    eq testMarriage =
        relationshipStatus("Gaia", single) age("Gaia", 999)
        neg(sister("Gaia", "Uranus")) female("Gaia")
        relationshipStatus("Uranus", single) age("Uranus", 900)
        neg(brother("Uranus", "Gaia")) male("Uranus") .

    op testBool : -> Configuration .
    eq testBool =
        birthday("Gaia") age("Gaia", 100) neg(birthday("Gaia"))
        neg(birthday("Gaia")) .

    ops testPL testPL2 test : Nat -> Configuration .
    eq testPL(PORT) =
        <> < aClient : Client | none > createClientSocket("localhost", PORT)
        male("thomas") age("thomas", 35) relationshipStatus("thomas", single)
        male("rolf") age("rolf", 60) relationshipStatus("rolf", single)
        female("anna") age("anna", 14) relationshipStatus("anna", single)
        female("maria") age("maria", 35) relationshipStatus("maria", single)
        parent("thomas", "anna")
        parent("maria", "anna")
        parent("rolf", "maria") .
        ---plQuery("sibling(rolf, maria)\n") .
        ---plQuery("father(rolf, maria)\n") .

    eq testPL2(PORT) =
        <> < aClient : Client | none >
        male("thomas") male("rolf") female("anna") female("maria")
        parent("thomas", "anna") parent("maria", "anna") parent("rolf", "maria")
        relationshipStatus("thomas", single)
        relationshipStatus("rolf", single)
        relationshipStatus("anna", single)
        relationshipStatus("maria", single) .

    eq test(PORT) =
        <> < aClient : Client | none >
        male("thomas") female("anna")
        parent("thomas", "anna")
        relationshipStatus("thomas", single)
        relationshipStatus("anna", single) .
endm


--- search =>* female("Hera") C:Configuration
--- funker ikke fordi spesifikasjonen ikke er terminerende. bruk heller:
--- search [1] =>* female("Hera") C:Configuration

















